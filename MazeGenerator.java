import java.io.*;
import java.util.*;

/**
 * Generates perfect Mazes with dimensions greater than 4, solves them using BFS and DFS, and finds the solution.
 * @author Dale Christian Seen and Konstantin Dimitrov
 *
 */
public class MazeGenerator
{
	private static final int DEFAULT_DIMENSION = 4;			// The Default Dimension of the maze
	
	private int dimension;									// The dimension of the maze
	
	private Random myRandGen;								// Random generator used to tear down walls between cells
	private Vertex[][] maze;								// 2D Array that will be used to position cells
	private ArrayList<Vertex> pathSolution;					// ArrayList containing the path of the solution generated by Graph Traversal methods.
	
	/**
	 * Default constructor, sets dimension to 4.
	 */
	public MazeGenerator()
	{
		dimension = DEFAULT_DIMENSION;
		myRandGen = new Random(0);
		pathSolution = new ArrayList<Vertex>();
		prepare2DArray();
	}
	
	/**
	 * Constructor that accepts an integer parameter and sets maze's dimension to that.
	 * @param _dim
	 */
	public MazeGenerator(int _dim)
	{
		dimension = _dim;
		myRandGen = new Random(0);
		pathSolution = new ArrayList<Vertex>();
		prepare2DArray();
	}	
	
	/**
	 * Generates random maze using DFS. (A fully "walled" vertex has no edges. Walls are "torn down" by creating edges between adjacent cells.)
	 */
	public void generateMaze()
	{
		LinkedList<Vertex> stack = new LinkedList<Vertex>();
		int totalCells = dimension * dimension;
		Vertex u = maze[0][0];
		int visitedCells = 1;
		while (visitedCells < totalCells)
		{
			ArrayList<Vertex> wallAdjs = findWalledAdjacents(u);
			if (wallAdjs != null)
			{
				Vertex nVertex = null;
				int randInt = (int)(myRandom() * wallAdjs.size());
				nVertex = wallAdjs.get(randInt);
				createEdge(u, nVertex);
				stack.addFirst(u);
				u = nVertex;
				visitedCells++;
			}
			else
			{
				u = stack.removeFirst();
			}
		}
	}
	
	/**
	 * Solve maze using BFS
	 */
	public void solveMazeBFS()
	{
		LinkedList<Vertex> queue = new LinkedList<Vertex>();
		Vertex u = maze[0][0];
		queue.addFirst(u);
		int order = 0;
		while(!queue.isEmpty() && !u.equals(maze[dimension-1][dimension-1]))
		{
			u = queue.removeLast();
			u.adjacents.sort(new Comparator<Vertex>()
					{
						public int compare(Vertex v1, Vertex v2)
						{
							if (v1.cellNumber > v2.cellNumber)
							{
								return -1;
							}
							else if (v1.cellNumber == v2.cellNumber)
							{
								return 0;
							}
							else
							{
								return 1;
							}
						}
					});
			for (Vertex v: u.adjacents)
			{
				if (v.visited == false)
				{
					v.prev = u;
					queue.addFirst(v);
				}
			}
			u.order = order++;
			u.visited = true;
		}
		calculateSolution();
	}
	
	/**
	 * Solve maze using DFS
	 */
	public void solveMazeDFS()
	{
		LinkedList<Vertex> stack = new LinkedList<Vertex>();
		Vertex u = maze[0][0];
		stack.addFirst(u);
		int order = 0;
		while(!stack.isEmpty() && !u.equals(maze[dimension-1][dimension-1]))
		{
			u = stack.removeFirst();
			u.adjacents.sort(new Comparator<Vertex>()
			{
				public int compare(Vertex v1, Vertex v2)
				{
					if (v1.cellNumber > v2.cellNumber)
					{
						return 1;
					}
					else if (v1.cellNumber == v2.cellNumber)
					{
						return 0;
					}
					else
					{
						return -1;
					}
				}
			});
			for (Vertex v : u.adjacents)
			{
				if (v.visited == false)
				{
					v.prev = u;
					stack.addFirst(v);
				}
			}
			u.order = order++;
			u.visited = true;
		}
		calculateSolution();
	}
	
	/**
	 * Resets the cells to allow a different search method to solve the maze
	 */
	public void reset()
	{
		for (int i = 0; i < dimension; i++)
		{
			for (int j = 0; j < dimension; j++)
			{
				maze[i][j].reset();
			}
		}
		pathSolution = new ArrayList<Vertex>();
	}
	
	/**
	 * Creates String format of unsolved maze that will be printed.
	 * @return String unsolved maze in string format.
	 */
	public String toStringInitialMaze()
	{
		String msg = "+ ";
		for (int i = 0; i < dimension - 1; i++)
		{
			msg += "+-";
		}
		msg += "+\r\n";
		
		
		for (int i = 0; i < dimension; i++)
		{
			for (int j = 0 ; j < dimension; j++)
			{
				if ((j-1) > -1 && isEdge(maze[i][j-1], maze[i][j]))
				{
					msg += "  ";
				}
				else
				{
					msg += "| ";
				}
			}
			msg += "|\r\n";
			for (int k = 0; k < dimension; k++)
			{
				if ((i+1) < dimension && isEdge(maze[i+1][k], maze[i][k]) || maze[i][k].cellNumber == (dimension*dimension)-1)
				{
					msg += "+ ";
				}
				else
				{
					msg += "+-";
				}
			}
			msg += "+\r\n";
		}
		return msg;
	}
	
	/**
	 * Creates String format of path taken by BFS as it had solved the maze
	 * @return String path of maze in string format.
	 */
	public String toStringOrderMaze()
	{
		String msg = "+ ";
		for (int i = 0; i < dimension - 1; i++)
		{
			msg += "+-";
		}
		msg += "+\r\n";
		
		
		for (int i = 0; i < dimension; i++)
		{
			for (int j = 0 ; j < dimension; j++)
			{
				if ((j-1) > -1 && isEdge(maze[i][j-1], maze[i][j]))
				{
					if (maze[i][j].order > -1)
					{
						msg += " " + maze[i][j].order%10;
					}
					else
					{
						msg += "  ";
					}
				}
				else
				{
					if (maze[i][j].order > -1)
					{
						msg += "|" + maze[i][j].order%10;
					}
					else
					{
						msg += "| ";
					}
				}
			}
			msg += "|\r\n";
			for (int k = 0; k < dimension; k++)
			{
				if ((i+1) < dimension && isEdge(maze[i+1][k], maze[i][k]) || maze[i][k].cellNumber == (dimension*dimension)-1)
				{
					msg += "+ ";
				}
				else
				{
					msg += "+-";
				}
			}
			msg += "+\r\n";
		}
		return msg;
	}
	
	/**
	 * Creates String format of path solution generated by BFS method
	 * @return String solved maze in String format.
	 */
	public String toStringSolvedMaze()
	{
		String msg = "+ ";
		for (int i = 0; i < dimension - 1; i++)
		{
			msg += "+-";
		}
		msg += "+\r\n";
		
		
		for (int i = 0; i < dimension; i++)
		{
			for (int j = 0 ; j < dimension; j++)
			{
				if ((j-1) > -1 && isEdge(maze[i][j-1], maze[i][j]))
				{
					if (isInPath(maze[i][j]))
					{
						msg += " #";
					}
					else
					{
						msg += "  ";
					}
				}
				else
				{
					if (isInPath(maze[i][j]))
					{
						msg += "|#";
					}
					else
					{
						msg += "| ";
					}
				}
			}
			msg += "|\r\n";
			for (int k = 0; k < dimension; k++)
			{
				if ((i+1) < dimension && isEdge(maze[i+1][k], maze[i][k]) || maze[i][k].cellNumber == (dimension*dimension)-1)
				{
					msg += "+ ";
				}
				else
				{
					msg += "+-";
				}
			}
			msg += "+\r\n";
		}
		return msg;
	}
	
	public int getDimension()
	{	return dimension;	}
	
	/**
	 * Helper method for solveMazeBFS() and solveMazeDFS()
	 * Calculates the solution generated by a search method.
	 */
	private void calculateSolution()
	{
		Vertex cNode = maze[dimension-1][dimension-1];
		Vertex nNode = cNode;
		pathSolution.add(cNode);
		while (!cNode.equals(maze[0][0]))
		{
			nNode = nNode.prev;
			if (isEdge(cNode,nNode))
			{
				pathSolution.add(nNode);
				cNode = nNode;
			}
		}
	}
	
	/**
	 * Helper method for toStringSolvedMaze()
	 * @param v A vertex that will be checked if it is within the path of the BFS Solution
	 * @return boolean True if Vertex is in path, false otherwise.
	 */
	private boolean isInPath(Vertex v)
	{
		int index = pathSolution.indexOf(v);
		if (index > -1)
		{
			pathSolution.remove(index);
			return true;
		}
		return false;
	}
	
	/**
	 * Helper method for generateMaze()
	 * Returns an ArrayList of adjacent cells to the given cell that have no edges.
	 * @param _v Vertex (cell) that will be checked
	 * @return ArrayList<Vertex> containing adjacent cells of a cell in the 2D array that has no edges.
	 */
	private ArrayList<Vertex> findWalledAdjacents(Vertex _v)
	{
		ArrayList<Vertex> wallAdjs = new ArrayList<Vertex>();
		
		int cRow = _v.cellNumber / dimension;
		int cCol = _v.cellNumber % dimension;
		
		if ((cRow+1) < dimension && maze[cRow+1][cCol].hasNoEdges())
		{
			wallAdjs.add(maze[cRow+1][cCol]);
		}
		if ((cCol+1) < dimension && maze[cRow][cCol+1].hasNoEdges())
		{
			wallAdjs.add(maze[cRow][cCol+1]);
		}
		if ((cRow-1) > -1 && maze[cRow-1][cCol].hasNoEdges())
		{
			wallAdjs.add(maze[cRow-1][cCol]);
		}
		if ((cCol-1) > -1 && maze[cRow][cCol-1].hasNoEdges())
		{
			wallAdjs.add(maze[cRow][cCol-1]);
		}
		
		if (wallAdjs.size() > 0)
		{
			return wallAdjs;
		}
		return null;
	}
	
	/**
	 * Helper method for Constructors
	 * Initializes the elements of the 2D array
	 */
	private void prepare2DArray()
	{
		maze = new Vertex[dimension][dimension];
		
		int counter = 0;
		for (int i = 0; i < dimension; i++)
		{
			for (int j = 0; j < dimension; j++)
			{
				maze[i][j] = new Vertex(counter++);
			}
		}
	}
	
	/**
	 * Helper method for generateMaze()
	 * Creates an edge between two vertices
	 * @param v1 Vertex at the end of the edge
	 * @param v2 Vertex at the other end of the edge
	 */
	private void createEdge(Vertex v1, Vertex v2)
	{
		v1.adjacents.add(v2);
		v2.adjacents.add(v1);
	}
	
	/**
	 * Helper method for toStringInitialMaze()
	 * Checks if an edge exists between two vertices
	 * @param v1 Vertex to be checked if edged with v2
	 * @param v2 Vertex to be checked if edged with v1
	 * @return
	 */
	private boolean isEdge(Vertex v1, Vertex v2)
	{
		ArrayList<Vertex> v1Adjs = v1.adjacents;
		ArrayList<Vertex> v2Adjs = v2.adjacents;
		
		if (v1Adjs.indexOf(v2) != -1 && v2Adjs.indexOf(v1) != -1)
		{
			return true;
		}
		return false;
	}
	
	/**
	 * Random generator function
	 * @return Double random value
	 */
	private double myRandom()
	{	return myRandGen.nextDouble();	}
	
	/**
	 * Vertex class that will represent the cells of the maze
	 * @author Dale Christian Seen and Konstantin Dimitrov
	 *
	 */
	private class Vertex
	{
		public ArrayList<Vertex> adjacents;			// ArrayList of adjacent vertices to this vertex
		
		public Vertex prev;
		
		public int cellNumber;						// This cell's number. This value will be used to find the vertex in the 2D array
		public int order;							// Will be used to find the solution to the maze
		
		public boolean visited;						// Determines if the vertex had been visited already
		
		/**
		 * Default constructor 
		 */
		public Vertex()
		{
			adjacents = new ArrayList<Vertex>();
			prev = null;
			cellNumber = 0;
			order = -1;
			visited = false;
		}
		
		/**
		 * Constructor that sets cell num to given argument
		 * @param _cellNum
		 */
		public Vertex(int _cellNum)
		{
			adjacents = new ArrayList<Vertex>();
			prev = null;
			cellNumber = _cellNum;
			order = -1;
			visited = false;
		}
		
		/**
		 * Sets the instance variables of a vertex to their default values
		 */
		public void reset()
		{
			prev = null;
			order = -1;
			visited = false;
		}
		
		/**
		 * Determines if a vertex has no edges
		 * @return boolean true if vertex has no edges, false if otherwise.
		 */
		public boolean hasNoEdges()
		{
			if (adjacents.size() == 0)
			{
				return true;
			}
			return false;
		}
	}
}
